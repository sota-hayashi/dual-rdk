<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
		<script src="https://unpkg.com/jspsych@8"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych-contrib/plugin-rdk@2.0.0"></script>
		<link rel="stylesheet" href="https://unpkg.com/jspsych@8/css/jspsych.css">
    <style>
      html, body {
        width: 100%;
        height: 100%;
      }
      .jspsych-display-element {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100%;
      }
      .response-container {
        width: 600px;
        height: 600px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .response-instruction {
        position: relative;
        top: -200px;
        text-align: center;
      }
      .response-circle {
        width: 300px;
        height: 300px;
        border-radius: 50%;
        position: absolute;
        margin: 20px auto;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      /* .response-circle::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 10px;
        height: 10px;
        background-color: red;
        border-radius: 50%;
        z-index: 10;
      } */
      .rotating-bar {
        width: 30px;
        height: 250px;
        background-color: black;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transform-origin: center center;
        clip-path: polygon(
          50% 0%,
          100% 15%,
          60% 15%,
          60% 100%,
          40% 100%,
          40% 15%,
          0% 15%
        );
      }
      .response-fixation {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 30px; /* 十字の幅 */
        height: 30px; /* 十字の高さ */
        pointer-events: none;
      }
      .response-fixation::before,
      .response-fixation::after {
        content: '';
        position: absolute;
        background-color: #111; /* 十字の色 */
      }
      .response-fixation::before {
        width: 2px; /* 縦線の太さ */
        height: 100%; /* 縦線の長さ */
        left: 50%;
        transform: translateX(-50%);
        opacity: 0.45;
      }
      .response-fixation::after {
        height: 2px; /* 横線の太さ */
        width: 100%; /* 横線の長さ */
        top: 50%;
        transform: translateY(-50%);
        transform: translateX(-50%);
        opacity: 0.45;
      }
      .instructions-container {
        max-width: 800px;
        margin: 20px auto;
        text-align: left;
        padding: 20px;
      }
    </style>
    <title>Experiment 1</title>
  </head>
  <body bgcolor="#AAA"></body>
  <script>
    console.log("--- スクリプトの読み込み開始 ---");

    // #region ----- jsPsychの初期化とデータ保存設定 -----
		var jsPsych = initJsPsych({
			on_finish: function() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        }
        const pad2 = (n) => String(n).padStart(2, '0');
        const now = new Date();
        const stamp = [
          now.getFullYear(),
          pad2(now.getMonth() + 1),
          pad2(now.getDate()),
          pad2(now.getHours()),
          pad2(now.getMinutes())
        ].join('');
        // --- CSVをその場でダウンロード（ブラウザが保存ダイアログを開く） ---
        jsPsych.data.get().localSave('csv', `experiment_data_${stamp}.csv`);

        // --- 追加で手動ダウンロード用リンクを表示 ---
        const csvString = jsPsych.data.get().csv();
        const blob = new Blob([csvString], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'experiment_data.csv';
        link.innerText = 'Download CSV again';
        link.style.display = 'block';
        link.style.margin = '20px';
        document.body.appendChild(link);

        // jsPsych.data.displayData();
			}
		});
    // #endregion


    // 表示位置の中心をログ出力するユーティリティ
    const logCenterPositions = (label, selector) => {
      const display = document.querySelector('.jspsych-display-element');
      const target = document.querySelector(selector);
      if (!display || !target) {
        console.warn(`[center-check] ${label}: element not found`, { display, target });
        return;
      }
      const displayRect = display.getBoundingClientRect();
      const targetRect = target.getBoundingClientRect();
      const displayCenter = {
        x: displayRect.left + displayRect.width / 2,
        y: displayRect.top + displayRect.height / 2
      };
      const targetCenter = {
        x: targetRect.left + targetRect.width / 2,
        y: targetRect.top + targetRect.height / 2
      };
      console.log(`[center-check] ${label}`, {
        displayCenter,
        targetCenter,
        delta: {
          x: targetCenter.x - displayCenter.x,
          y: targetCenter.y - displayCenter.y
        },
        displayRect,
        targetRect
      });
    };


    var timeline = [];
    let lastRdkResult = null;

    // #region ----- ウェルカムメッセージ，タスク説明，固定視標と休憩 -----

    // フルスクリーン化を試みる（ブラウザの制約で拒否される場合がある）
    const requestFullscreen = () => {
      const el = document.documentElement;
      if (!document.fullscreenElement && el.requestFullscreen) {
        el.requestFullscreen().catch((err) => {
          console.warn('Fullscreen request was blocked:', err);
        });
      }
    };
    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "Welcome to the experiment. Press any key to begin.",
      on_finish: () => {
        // ユーザーのキー入力に続けてフルスクリーンを要求（ブラウザポリシー回避）
        requestFullscreen();
      }
    };

    const instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="instructions-container">
          <h2>Instructions</h2>
          <p>In this experiment, you will see <strong>two random dot kinematograms (RDKs)</strong> simultaneously.</p>
          <p>RDK consists of white dots or black dots moving in a specific direction.</p>
          <p>Your task is to determine the direction of the <strong>target RDK</strong> based on the <strong>number of dots</strong>.</p>
          <p>For instance, if the white RDK has more dots than the black RDK, the white RDK is the target so you should respond to the direction of the white RDK.</p>
          <p>After viewing the RDKs, you will rotate a bar to indicate the perceived direction of the target RDK using the <strong>left and right arrow keys</strong>. <strong>Press Enter</strong> when you are ready to submit your response.</p>
          <p>You will receive points based on the <strong>accuracy of your response</strong>. Try to be as accurate as possible!</p>
          <p>You will have three practice trials. Press <strong>Enter</strong> key to start the practice phase.</p>
        </div>
      `,
      choices: ['Enter']
    };

    const finishpractice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="instructions-container">
          <h2>End of Practice</h2>
          <p>You have completed the practice trials.</p>
          <p>Press <strong>Enter</strong> key to begin the main experiment.</p>
        </div>
      `,
      choices: ['Enter']
    };

    const fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<div class="fixation" style="font-size: 60px;">+</div>',
      choices: "NO_KEYS",
      trial_duration: 1000,
      on_load: () => {
        // レイアウト確定後に中心座標を記録
        requestAnimationFrame(() => logCenterPositions('fixation', '.fixation'));

      }
    };

    const breaktime = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div id="break-timer" style="font-size: 24px; text-align: center;">
          <p>Take a short break! You have 30 seconds.</p>
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: null,
      on_load: () => {
        let remaining = 30;
        let readyForKey = false;
        const el = document.getElementById('break-timer');

        const render = () => {
          const prompt = readyForKey ? '<p>Press any key to continue.</p>' : '';
          el.innerHTML = `<p>Break time: ${remaining} seconds</p>${prompt}`;
        };

        render();
        const intervalId = setInterval(() => {
          remaining -= 1;
          if (remaining <= 0) {
            remaining = 0;
            readyForKey = true;
            clearInterval(intervalId);
            render();
            jsPsych.pluginAPI.getKeyboardResponse({
              callback_function: (info) => {
                clearInterval(intervalId);
                jsPsych.finishTrial({ key_press: info.key, rt: info.rt });
              },
              valid_responses: "ALL_KEYS",
              rt_method: 'performance',
              persist: false
            });
          } else {
            render();
          }
        }, 1000);
      }
    };
    // #endregion


    // #region ----- ハイパーパラメータの定義 -----
    const numSessions = 3;
    const numTrials = 32;

    //--- テンプレート方向区間とセッション回転量を定義して隠れ報酬構造を再現する ---
    const templateRanges = {
      W_H: [0, 45],
      B_H: [90, 135],
      W_L: [180, 225],
      B_L: [270, 315]
    };
    // #endregion


    // #region ----- セッションごとで変化しないパラメータ・関数を定義 -----
    //--- RDK試行の条件テンプレート ---
    const templateConditions =[
      { label: 'W_H_vs_B_L', white_range: 'W_H', black_range: 'B_L', target_group: 'white'},
      { label: 'B_H_vs_W_L', white_range: 'W_L', black_range: 'B_H', target_group: 'black'}
    ];
    const templateLength = templateConditions.length;
    //--- テンプレートをnumTrials試行数分複製し，ランダムに並べ替えたセッション条件を用意する ---
    const baseConditions = [];
    templateConditions.forEach((condition) => {
      for (let i = 0; i < numTrials / templateLength; i++) {
        baseConditions.push({
          ...condition,
          label: `${condition.label}_rep${i + 1}`
        });
      }
    });
    // セッションごとで変わるランダムな回転量[0, 359]を生み出す関数
    const generateRandomInt = () => {
      var randomAngle = Math.floor(Math.random() * 360);
      return randomAngle;
    };
    // RDK条件をランダムに並べ替える関数
    const generateRdkConditions = () => {
      const shuffledConditions = jsPsych.randomization.shuffle(baseConditions);
      return shuffledConditions;
    };
    // #endregion


    // #region ----- セッションごとで変化するパラメータを定義 -----
    var sessionRotation = generateRandomInt();
    var shuffledBaseConditions = generateRdkConditions();
    // console.log(`Session rotation angle: ${sessionRotation} degrees`);
    // #endregion
  

    // #region ----- セッションごとで変化するRDK条件群を生成する関数 -----
    const rotateAngle = (angle) => (angle + sessionRotation) % 360;
    const sampleDirectionFromRange = (range) => {
      const width = range[1] - range[0];
      const baseAngle = Math.floor(range[0] + Math.random() * width);
      return rotateAngle(baseAngle);
    };
    let rdk_conditions = [];
    const rdkConditions = () => shuffledBaseConditions.map((condition) => {
      //--- 方向差が90°未満なら再サンプル（最大20回で打ち切り） ---
      let whiteDirection = sampleDirectionFromRange(templateRanges[condition.white_range]);
      let blackDirection = sampleDirectionFromRange(templateRanges[condition.black_range]);
      let attempts = 1;
      const maxAttempts = 20;
      const normalizedDiff = (w, b) => {
        const raw = Math.abs(w - b);
        return raw > 180 ? 360 - raw : raw;
      };
      let angularDiff = normalizedDiff(whiteDirection, blackDirection);
      // 45 < diff < 90を満たすまで最大20回ループしている．
      // だから，ターゲットじゃない方向を答えた場合，15°の誤差で報酬は０になる．
      while (angularDiff < 45 && attempts < maxAttempts || angularDiff > 90 && attempts < maxAttempts) {
        whiteDirection = sampleDirectionFromRange(templateRanges[condition.white_range]);
        blackDirection = sampleDirectionFromRange(templateRanges[condition.black_range]);
        angularDiff = normalizedDiff(whiteDirection, blackDirection);
        attempts += 1;
      }

      console.log(`White direction: ${whiteDirection}, Black direction: ${blackDirection}, attempts: ${attempts}, diff: ${angularDiff}`);

      const basePairs = [
        { color: 'white', direction: whiteDirection, dots: 100, group: 'white' },
        { color: 'black', direction: blackDirection, dots: 100, group: 'black' }
      ];
      const finalPairs = Math.random() < 0.5 ? basePairs : basePairs.slice().reverse();
      console.log('Final pairs order:', finalPairs);
      const directions = finalPairs.map((p) => p.direction);
      const dotColors = finalPairs.map((p) => p.color);
      const dots = finalPairs.map((p) => p.dots);
      const targetIndex = finalPairs.findIndex((p) => p.group === condition.target_group);

      return {
        dots,
        directions,
        target_index: targetIndex,
        target_group: condition.target_group,
        condition_label: condition.label,
        dot_color: dotColors
      };
    });
    // #endregion


    // #region ----- RDK刺激を表示し高低報酬条件を記録する試行テンプレート -----
    const rdk_template = {
      type: jsPsychRdk,
      number_of_dots: jsPsych.timelineVariable('dots'),
      coherent_direction: jsPsych.timelineVariable('directions'),
      dot_color: jsPsych.timelineVariable('dot_color'),
      correct_choice: ['a'],
      trial_duration: 2000,
      response_ends_trial: false,
      background_color: '#AAA',
      number_of_apertures: 2,
      border: true,
      border_color: 'transparent',
      border_thickness: 2,
      aperture_width: 300,
      aperture_height: 300,
      aperture_center_x: () => window.innerWidth/2,
      aperture_center_y: () => window.innerHeight/2,
      RDK_type: 3,
      coherence: [1.0, 1.0],
      fixation_cross: true,
      fixation_cross_width: 15,
      fixation_cross_height: 15,
      fixation_cross_color: '#111',
      fixation_cross_thickness: 1,
      data: {
        target_group: jsPsych.timelineVariable('target_group'),
        target_index: jsPsych.timelineVariable('target_index'),
        condition_label: jsPsych.timelineVariable('condition_label')
      },
      on_load: function() {
        
      },
      on_finish: function(data) {
        data.target_direction = data.coherent_direction[data.target_index];
        data.distractor_direction = data.coherent_direction[1 - data.target_index];
        lastRdkResult = {
          target_direction: data.target_direction,
          distractor_direction: data.distractor_direction,
          target_group: data.target_group
        };
      }
    };
    // #endregion


    // #region ----- 矢印キーでバーを回転させ回答角度を記録する試行テンプレート（タップで一度ずつになっていないのと，長押しで2段階くらいの速度を用意したい） -----
    let responseAngle = 90;

    const direction_response_trial = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="response-container">
          <div class="response-instruction">
            <p>rotate the bar by using the left and right arrow keys.</p>
            <p>when you are determined, press the Enter key.</p>
          </div>
          <div class="response-circle">
            <div class="response-fixation"></div>
            <div id="bar" class="rotating-bar"></div>
          </div>
        </div>
      `,
      choices: ['Enter'],
      on_load: function() {
        responseAngle = Math.floor(Math.random() * 360) % 360;
        const bar = document.getElementById('bar');
        bar.style.transform = `translate(-50%, -50%) rotate(${responseAngle}deg)`;
        const keysDown = { ArrowLeft: false, ArrowRight: false };
        let holdStartTime = null;
        let animationFrameId = null;
        let isTap = false;

        const rotateBar = () => {
          const holdDuration = Date.now() - holdStartTime;
          if (holdDuration > 150) {
            isTap = false;
          }
          let step = holdDuration > 1000 ? 2 : 1;
          // step = holdDuration > 2000 ? 4 : 2;

          if (keysDown.ArrowLeft) {
            responseAngle -= step;
          }
          if (keysDown.ArrowRight) {
            responseAngle += step;
          }
          bar.style.transform = `translate(-50%, -50%) rotate(${responseAngle}deg)`;
          if (keysDown.ArrowLeft || keysDown.ArrowRight) {
            animationFrameId = requestAnimationFrame(rotateBar);
          } else {
            animationFrameId = null;
          }
        };

        const keydownListener = (event) => {
          if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') {
            return;
          }
          if (event.repeat) {
            return;
          }
          keysDown[event.key] = true;
          isTap = true;
          if (!animationFrameId) {
            holdStartTime = Date.now();
            animationFrameId = requestAnimationFrame(rotateBar);
          }
        };

        const keyupListener = (event) => {
          if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') {
            return;
          }
          keysDown[event.key] = false;
          if (isTap) {
            responseAngle += event.key === 'ArrowLeft' ? -1 : 1;
            bar.style.transform = `translate(-50%, -50%) rotate(${responseAngle}deg)`;
          }
          isTap = false;
        };

        window.addEventListener('keydown', keydownListener);
        window.addEventListener('keyup', keyupListener);

        jsPsych.pluginAPI.getKeyboardResponse({
          callback_function: () => {
            window.removeEventListener('keydown', keydownListener);
            window.removeEventListener('keyup', keyupListener);
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
            }
          },
          valid_responses: ['Enter'],
          rt_method: 'performance',
          persist: false
        });
      },
      on_finish: function(data) {
        data.response_angle_css = responseAngle;
        const convertedAngle = (450 - responseAngle + 360) % 360;
        data.response_angle_rdk = convertedAngle;
        if (lastRdkResult) {
          let angularErrorTarget = convertedAngle - lastRdkResult.target_direction;
          let angularErrorDistractor = convertedAngle - lastRdkResult.distractor_direction;
          if (angularErrorTarget > 180) {
            angularErrorTarget -= 360;
          }
          if (angularErrorTarget < -180) {
            angularErrorTarget += 360;
          }
          if (angularErrorDistractor > 180) {
            angularErrorDistractor -= 360;
          }
          if (angularErrorDistractor < -180) {
            angularErrorDistractor += 360;
          }
          const angularError = Math.abs(angularErrorTarget) < Math.abs(angularErrorDistractor)
            ? angularErrorTarget
            : angularErrorDistractor;
          data.angular_error = angularError;
          data.target_direction = lastRdkResult.target_direction;
          data.target_group = lastRdkResult.target_group;
          // 本来，target_group = whiteの場合にblackの方向角度を回答した場合に報酬が0になるようにしたいが，
          // 現時点ではAEが45°を超えると報酬が0になるようになっているので，
          // それぞれの刺激の方向が90°以上離れていることさえ保証すれば良い．
          const rewardPoints = Math.max(0, Math.floor(10 * (1 - Math.abs(angularErrorTarget) / 45)))
          data.reward_points = rewardPoints;
          data.rotation_angle = sessionRotation;
        }
      }
    };
    // #endregion


    // #region ----- 報酬表示のテンプレートで連続報酬を即時フィードバック -----
    const reward_feedback_trial = {
      type: jsPsychHtmlKeyboardResponse,
      choices: 'NO_KEYS',
      trial_duration: 2000,
      stimulus: function() {
        const lastResponse = jsPsych.data.get().last(1).values()[0];
        const rewardPoints = lastResponse && typeof lastResponse.reward_points === 'number'
          ? lastResponse.reward_points
          : 0;
        const color = rewardPoints > 2 ? '#00FF00' : '#FF3333';
        return `
          <p style="color: ${color};">Your reward: ${rewardPoints} points</p>
        `;
      }
    };
    // #endregion

  
    // #region ----- 実験手順の構築・実行 -----
    timeline.push(welcome, instructions);
      // #region 練習セッションの構築 
    const rdk_practice_1 = {
      type: jsPsychRdk,
      number_of_dots: [50, 100],
      coherent_direction: [10, 100],
      correct_choice: ['a'],
      trial_duration: 2000,
      response_ends_trial: false,
      background_color: '#AAA',
      number_of_apertures: 2,
      border: true,
      border_color: 'transparent',
      border_thickness: 2,
      aperture_width: 300,
      aperture_height: 300,
      aperture_center_x: () => window.innerWidth/2,
      aperture_center_y: () => window.innerHeight/2,
      RDK_type: 3,
      dot_color: ['white', 'black'],
      coherence: [1.0, 1.0],
      fixation_cross: true,
      fixation_cross_width: 15,
      fixation_cross_height: 15,
      fixation_cross_color: '#111',
      fixation_cross_thickness: 1,
      data: {
        target_group: 'black',
        target_index: 1,
        condition_label: 'B_H_vs_W_L'
      },
      on_finish: function(data) {
        data.target_direction = data.coherent_direction[data.target_index];
        data.distractor_direction = data.coherent_direction[1 - data.target_index];
        lastRdkResult = {
          target_direction: data.target_direction,
          distractor_direction: data.distractor_direction,
          target_group: data.target_group
        };
      }
    };
    const rdk_practice_2 = {
    type: jsPsychRdk,
      number_of_dots: [100, 50],
      coherent_direction: [150, 30],
      correct_choice: ['a'],
      trial_duration: 2000,
      response_ends_trial: false,
      background_color: '#AAA',
      number_of_apertures: 2,
      border: true,
      border_color: 'transparent',
      border_thickness: 2,
      aperture_width: 300,
      aperture_height: 300,
      aperture_center_x: () => window.innerWidth/2,
      aperture_center_y: () => window.innerHeight/2,
      RDK_type: 3,
      dot_color: ['white', 'black'],
      coherence: [1.0, 1.0],
      fixation_cross: true,
      fixation_cross_width: 15,
      fixation_cross_height: 15,
      fixation_cross_color: '#111',
      fixation_cross_thickness: 1,
      data: {
        target_group: 'white',
        target_index: 0,
        condition_label: 'W_H_vs_B_L'
      },
      on_finish: function(data) {
        data.target_direction = data.coherent_direction[data.target_index];
        data.distractor_direction = data.coherent_direction[1 - data.target_index];
        lastRdkResult = {
          target_direction: data.target_direction,
          distractor_direction: data.distractor_direction,
          target_group: data.target_group
        };
      }
    };
    const rdk_practice_3 = {
      type: jsPsychRdk,
      number_of_dots: [50, 100],
      coherent_direction: [270, 180],
      correct_choice: ['a'],
      trial_duration: 2000,
      response_ends_trial: false,
      background_color: '#AAA',
      number_of_apertures: 2,
      border: true,
      border_color: 'transparent',
      border_thickness: 2,
      aperture_width: 300,
      aperture_height: 300,
      aperture_center_x: () => window.innerWidth/2,
      aperture_center_y: () => window.innerHeight/2,
      RDK_type: 3,
      dot_color: ['white', 'black'],
      coherence: [1.0, 1.0],
      fixation_cross: true,
      fixation_cross_width: 15,
      fixation_cross_height: 15,
      fixation_cross_color: '#111',
      fixation_cross_thickness: 1,
      data: {
        target_group: 'black',
        target_index: 1,
        condition_label: 'B_H_vs_W_L'
      },
      on_finish: function(data) {
        data.target_direction = data.coherent_direction[data.target_index];
        data.distractor_direction = data.coherent_direction[1 - data.target_index];
        lastRdkResult = {
          target_direction: data.target_direction,
          distractor_direction: data.distractor_direction,
          target_group: data.target_group
        };
      }
    };
    timeline.push(fixation, rdk_practice_1, direction_response_trial, reward_feedback_trial);
    responseAngle = Math.floor(Math.random() * 360) % 360;
    timeline.push(fixation, rdk_practice_2, direction_response_trial, reward_feedback_trial);
    responseAngle = Math.floor(Math.random() * 360) % 360;
    timeline.push(fixation, rdk_practice_3, direction_response_trial, reward_feedback_trial);
    timeline.push(finishpractice);
      // #endregion

    for (let session = 0; session < numSessions; session++) {
      sessionRotation = generateRandomInt();
      shuffledBaseConditions = generateRdkConditions();
      console.log(`Session rotation angle: ${sessionRotation} degrees`);
      rdk_conditions = rdkConditions();
      rdk_procedure = {
        timeline: [fixation, rdk_template, direction_response_trial, reward_feedback_trial],
        timeline_variables: rdk_conditions
      };
      timeline.push(rdk_procedure);
      if (session < numSessions - 1) {
        timeline.push(breaktime);
      }
    }

    jsPsych.run(timeline);
    // #endregion

    console.log("--- jsPsych.run() が呼び出された ---");
  </script>
</html>
